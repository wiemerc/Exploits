#!/usr/bin/env python3


import sys
from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser
from base64 import b64decode, b64encode
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler, HTTPServer
from loguru import logger
# The stuff in spnego._ntlm_raw is not meant to be used directly, but I didn't feel like implementing the protocol
# myself and the message classes are easier to use (and better written imo) than the classes from impacket.
from spnego._ntlm_raw import messages
from spnego._ntlm_raw.crypto import compute_response_v1, lmowfv1, ntowfv1


EXIT_OK = 0
EXIT_ERROR = 1

STATE_INITIAL = 0
STATE_NEGOTIATE_RECEIVED = 1
STATE_CHALLENGE_SENT = 2

HTML_BODY = """
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Brought to you by Constantin Wiemer</title>
  </head>
  <body>
    <pre>
      / __ )   _____  ____   __  __   ____ _   / /_   / /_         / /_  ____           __  __  ____   __  __          / /_    __  __         / ____/  ____    ____    _____  / /_  ____ _   ____   / /_   (_)   ____        | |     / /   (_)  ___    ____ ___   ___    _____
      / __  |  / ___/ / __ \ / / / /  / __ `/  / __ \ / __/        / __/ / __ \         / / / / / __ \ / / / /         / __ \  / / / /        / /      / __ \  / __ \  / ___/ / __/ / __ `/  / __ \ / __/  / /   / __ \       | | /| / /   / /  / _ \  / __ `__ \ / _ \  / ___/
      / /_/ /  / /    / /_/ // /_/ /  / /_/ /  / / / // /_         / /_  / /_/ /        / /_/ / / /_/ // /_/ /         / /_/ / / /_/ /        / /___   / /_/ / / / / / (__  ) / /_  / /_/ /  / / / // /_   / /   / / / /       | |/ |/ /   / /  /  __/ / / / / / //  __/ / /    
      /_____/  /_/     \____/ \__,_/   \__, /  /_/ /_/ \__/         \__/  \____/         \__, /  \____/ \__,_/         /_.___/  \__, /         \____/   \____/ /_/ /_/ /____/  \__/  \__,_/  /_/ /_/ \__/  /_/   /_/ /_/        |__/|__/   /_/   \___/ /_/ /_/ /_/ \___/ /_/     
                                      /____/                                            /____/                                 /____/                                                                                                                                            
    </pre>
  </body>
</html>
"""


# Good description of the NTLM protocol: https://curl.se/rfc/ntlm.html
class RequestHandlerWithNtlmAuth(BaseHTTPRequestHandler):
    # These have to be class variables as for every request a new object is created.
    state = STATE_INITIAL
    last_challenge = None


    def do_GET(self):
        logger.info(f"Received GET request from {self.client_address} to {self.path} with headers \n{self.headers}")
        self.protocol_version = "HTTP/1.1"
        # TODO: We should probably check if a new connection was used and reset the state to STATE_INITIAL if so
        #       (maintain the state per connection).
        try:
            if not "Authorization" in self.headers:
                logger.debug("Request without Authorization header received")
                if self.path == "/favicon.ico":
                    self.send_response(HTTPStatus.NOT_FOUND)
                    self.send_header("Content-Length", "0")
                    self.end_headers()
                else:
                    self.send_response(HTTPStatus.UNAUTHORIZED)
                    self.send_header("WWW-Authenticate", "NTLM")
                    self.send_header("Connection", "close")
                    self.send_header("Content-Length", "0")
                    self.end_headers()
            elif self.headers["Authorization"].startswith("NTLM"):
                _, token = self.headers["Authorization"].split()
                token = b64decode(token)
                if RequestHandlerWithNtlmAuth.state == STATE_INITIAL:
                    nego_msg = messages.Negotiate.unpack(token)
                    logger.debug(
                        f"Received NTLM negotiate message, flags={hex(nego_msg.flags)}, host={nego_msg.workstation}"
                    )
                    RequestHandlerWithNtlmAuth.state = STATE_NEGOTIATE_RECEIVED

                    logger.debug("Sending NTLM challenge message")
                    self.send_response(HTTPStatus.UNAUTHORIZED)
                    with open("/dev/random", "rb") as f:
                        RequestHandlerWithNtlmAuth.last_challenge = f.read(8)
                    challenge_msg = messages.Challenge(
                        flags=messages.NegotiateFlags.oem | messages.NegotiateFlags.ntlm | messages.NegotiateFlags.target_type_server,
                        target_name="www.example.com",
                        server_challenge=RequestHandlerWithNtlmAuth.last_challenge
                    )
                    self.send_header("WWW-Authenticate", "NTLM " + b64encode(challenge_msg.pack()).decode())
                    # The next header is necessary with curl, although with HTTP/1.1 all connections should be
                    # persistent. Without it curl closes the connection and restarts the NTLM handshake with the
                    # next request.
                    self.send_header("Connection", "keep-alive")
                    self.send_header("Content-Length", "0")
                    self.end_headers()
                    RequestHandlerWithNtlmAuth.state = STATE_CHALLENGE_SENT
                elif RequestHandlerWithNtlmAuth.state == STATE_CHALLENGE_SENT:
                    auth_msg = messages.Authenticate.unpack(token)
                    logger.debug(
                        f"Received NTLM authenticate message, user={auth_msg.user_name}, response={auth_msg.nt_challenge_response}"
                    )
                    RequestHandlerWithNtlmAuth.state = STATE_INITIAL
                    computed_response = compute_response_v1(
                        flags=0,
                        lm_hash=lmowfv1("consti123"),
                        nt_hash=ntowfv1("consti123"),
                        server_challenge=RequestHandlerWithNtlmAuth.last_challenge,
                        client_challenge=None
                    )[0]
                    if computed_response == auth_msg.nt_challenge_response:
                        logger.info(f"User '{auth_msg.user_name}' successfully authenticated")
                        self.send_response(HTTPStatus.OK)
                        self.send_header("Content-Length", str(len(HTML_BODY.encode())))
                        self.end_headers()
                        self.wfile.write(HTML_BODY.encode())
                    else:
                        logger.error(f"Wrong response received, expected {computed_response}, received {auth_msg.nt_challenge_response}")
                        self.send_response(HTTPStatus.UNAUTHORIZED)
                        self.send_header("Content-Length", "0")
                        self.end_headers()
                else:
                    logger.error(f"Server is in incorrect state {RequestHandlerWithNtlmAuth.state}")
                    self.send_response(HTTPStatus.INTERNAL_SERVER_ERROR)
                    self.send_header("Content-Length", "0")
                    self.end_headers()
            else:
                logger.error(f"Request with incorrect Authorization header '{self.headers['Authorization']}' received")
                self.send_response(HTTPStatus.BAD_REQUEST)
                self.send_header("Content-Length", "0")
                self.end_headers()
        except Exception:
            logger.exception("Exception occurred while processing the request:")
            self.send_response(HTTPStatus.INTERNAL_SERVER_ERROR)
            self.send_header("Content-Length", "0")
            self.end_headers()


    def log_request(self, code: int | str = "-", size: int | str = "-"):
        logger.info(f"Sending response with status code {str(code)}")


def main() -> int:
    parser = ArgumentParser(description="A simple web server with NTLM authentication", formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("--listen-addr", default="127.0.0.1")
    parser.add_argument("--listen-port", type=int, default=8081)
    args = parser.parse_args()

    logger.info("Starting server...")
    try:
        server = HTTPServer((args.listen_addr, args.listen_port), RequestHandlerWithNtlmAuth)
        server.serve_forever()
    except KeyboardInterrupt:
        logger.info("Shutting down server...")
    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main())
