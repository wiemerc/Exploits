#include <arpa/inet.h>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>


static const int MAX_CHUNK_SIZE = 4096;

static const int b64_index[256] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,  0,  0,  0,  0,
    0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,  63, 0,  26, 27, 28, 29, 30, 31, 32, 33,
    34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
};


class HTTPChunk
{
    uint8_t* mp_buffer;
    uint16_t m_buffer_size;

    public:
        HTTPChunk(std::istream& is, size_t size)
        {
            m_buffer_size = size <= MAX_CHUNK_SIZE ? size : MAX_CHUNK_SIZE;
            mp_buffer = new uint8_t[m_buffer_size];
            is.read(reinterpret_cast<char*>(mp_buffer), m_buffer_size);

            // skip over the terminating \r\n sequence
            char dummy;
            is.get(dummy);
            is.get(dummy);
        }

        // The destructor is virtual because in a derived class (which overrides get_content()), it might have to do more.
        virtual ~HTTPChunk()
        {
            std::cerr << "Destructor of HTTPChunk called" << std::endl;
            delete[] mp_buffer;
        }

        uint16_t get_size() const
        {
            return m_buffer_size * 3 / 4;
        }

        virtual void get_content(uint8_t* p_buffer)
        {
            // Code below copied and slightly adapted from https://stackoverflow.com/a/41094722
            // TODO: Check that j < size of buffer
            int pad = m_buffer_size > 0 && (m_buffer_size % 4 || mp_buffer[m_buffer_size - 1] == '=');
            size_t len = ((m_buffer_size + 3) / 4 - pad) * 4, i = 0, j = 0;

            for (i = 0, j = 0; i < len; i += 4) {
                int n = b64_index[mp_buffer[i]] << 18 |
                    b64_index[mp_buffer[i + 1]] << 12 |
                    b64_index[mp_buffer[i + 2]] << 6 |
                    b64_index[mp_buffer[i + 3]];
                p_buffer[j++] = n >> 16;
                p_buffer[j++] = n >> 8 & 0xff;
                p_buffer[j++] = n & 0xff;
            }
            if (pad) {
                int n = b64_index[mp_buffer[len]] << 18 | b64_index[mp_buffer[len + 1]] << 12;
                p_buffer[j++] = n >> 16;

                if (m_buffer_size > len + 2 && mp_buffer[len + 2] != '=') {
                    n |= b64_index[mp_buffer[len + 2]] << 6;
                    p_buffer[j] = n >> 8 & 0xff;
                }
            }

            // TODO: Throw exception only if message is not encoded correctly
            throw std::runtime_error("Decoding message failed");
        }
};


void pwned_destructor()
{
    std::cerr << "\x1b[31mYou've been pwned!!!\x1b[30m" << std::endl;
}


int main()
{
    std::fprintf(stderr, "Address of pwned destructor = %p\n", pwned_destructor);
    std::fprintf(stderr, "Size of Message objects = %ld\n", sizeof(HTTPChunk));

    // Read request with headers
    std::string line;
    while (std::getline(std::cin, line)) {
        // remove trailing \r
        line.erase(line.find("\r"));
        std::cerr << "> " << line << std::endl;
        if (line == "")
            break;
    }

    // Read data in chunks
    std::vector<HTTPChunk*> chunks;
    unsigned long chunk_num = 0, chunk_size;
    while (true) {
        std::getline(std::cin, line);
        line.erase(line.find("\r"));
        ++chunk_num;
        chunk_size = std::stoul(line, nullptr, 16);
        std::cerr << "Chunk #" << chunk_num << " has " << chunk_size << " bytes" << std::endl;

        if (chunk_size == 0) {
            std::cerr << "Final chunk received, terminating" << std::endl;
            std::cout << "HTTP/1.1 200 OK\r\n";
            break;
        }
        else if (chunk_size <= MAX_CHUNK_SIZE) {
            // Allocate HTTPChunk object and store it in list
            auto p_chunk = new HTTPChunk(std::cin, chunk_size);
            chunks.push_back(p_chunk);
            std::fprintf(stderr, "Chunk object at %p, size = %d\n", p_chunk, p_chunk->get_size());
        }
        else {
            std::cerr << "Chunk size " << chunk_size << " exceeds maximum size, aborting" << std::endl;
            std::cout << "HTTP/1.1 400 Bad Request\r\n";
            break;
        }
    }

    // We try to decode the chunks and, if an exception occurs, delete the object but keep it in the list. Therefore
    // the list will contain pointers to freed memory. In the next loop iteration the memory of the deleted object will
    // be re-used for the buffer and overwritten with the data of the next chunk.
    for (auto p_chunk : chunks) {
        try {
            auto p_decoded_chunk = new uint8_t[p_chunk->get_size()];
            std::fprintf(stderr, "Buffer for decoded chunk at %p\n", p_decoded_chunk);
            p_chunk->get_content(p_decoded_chunk);
            // Do something with the decoded chunk...
        }
        catch (std::exception& e) {
            std::fprintf(stderr, "Exception '%s' occurred while decoding chunk, deleting object\n", e.what());
            delete p_chunk;
        }
    }

    // Later in the code, delete all chunks and thereby trigger UAF condition
    for (auto p_chunk : chunks) {
        delete p_chunk;
    }
    return 0;
}