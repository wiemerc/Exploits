#include <arpa/inet.h>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>


static const int BUFFER_SIZE = 1024;
static const int MSG_DATA = 1;
static const int MSG_END = 2;

static const int b64_index[256] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,  0,  0,  0,  0,
    0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,  63, 0,  26, 27, 28, 29, 30, 31, 32, 33,
    34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
};


// Message format: | type | size | base64-encoded message |
// TODO: Use HTTP chunked transfer instead of our home-grown "protocol"
class Message
{
    uint8_t m_buffer[BUFFER_SIZE];
    uint16_t m_buffer_size;
    uint16_t m_type;
    uint16_t m_size;

    public:
    Message(const char* p_buffer, size_t size)
    {
        m_buffer_size = size <= BUFFER_SIZE ? size : BUFFER_SIZE;
        std::memcpy(m_buffer, p_buffer, m_buffer_size);
        m_type = ntohs(*((uint16_t*) m_buffer));
        m_size = ntohs(*((uint16_t*) (m_buffer + 2)));
        m_buffer_size -= 4;
    }

    virtual ~Message()
    // TODO: Delete buffer
    {
    }

    virtual void decode(uint8_t* p_buffer)
    {
        // Code below copied and slightly adapted from https://stackoverflow.com/a/41094722
        // TODO: Check that j < size of buffer
        int pad = m_buffer_size > 0 && (m_buffer_size % 4 || m_buffer[m_buffer_size - 1] == '=');
        size_t len = ((m_buffer_size + 3) / 4 - pad) * 4, i = 0, j = 0;

        for (i = 4, j = 0; i < len; i += 4) {
            int n = b64_index[m_buffer[i]] << 18 |
                b64_index[m_buffer[i + 1]] << 12 |
                b64_index[m_buffer[i + 2]] << 6 |
                b64_index[m_buffer[i + 3]];
            p_buffer[j++] = n >> 16;
            p_buffer[j++] = n >> 8 & 0xff;
            p_buffer[j++] = n & 0xff;
        }
        if (pad) {
            int n = b64_index[m_buffer[len]] << 18 | b64_index[m_buffer[len + 1]] << 12;
            p_buffer[j++] = n >> 16;

            if (m_buffer_size > len + 2 && m_buffer[len + 2] != '=') {
                n |= b64_index[m_buffer[len + 2]] << 6;
                p_buffer[j] = n >> 8 & 0xff;
            }
        }

        // TODO: Throw exception only if message is not encoded correctly
        throw std::runtime_error("Decoding message failed");
    }

    virtual uint16_t get_type() const
    {
        return m_type;
    }

    uint16_t get_size() const
    {
        return m_size;
    }
};


void pwned_get_type()
{
    std::cerr << "\x1b[31mYou've been pwned!!!\x1b[30m" << std::endl;
}


int main()
{
    std::fprintf(stderr, "Address of pwned_get_type() = %p\n", pwned_get_type);
    std::fprintf(stderr, "Size of Message objects = %ld\n", sizeof(Message));

    char read_buffer[BUFFER_SIZE];
    std::vector<Message*> messages;
    while (true) {
        std::cin.read(read_buffer, BUFFER_SIZE);
        std::fprintf(stderr, "Read %ld bytes from standard input\n", std::cin.gcount());

        // Allocate Message object and store it in list
        auto p_msg = new Message(read_buffer, std::cin.gcount());
        messages.push_back(p_msg);
        std::fprintf(stderr, "Message object at %p, size = %d, type = %d\n", p_msg, p_msg->get_size(), p_msg->get_type());

        // We need to terminate the loop with special message instead of EOF because EOF can only be caused by closing
        // the TCP connection and this causes socat to terminate the program.
        if (p_msg->get_type() == MSG_END) break;
    }

    // We try to decode message and, if an exception occurs, delete object but keep it in list. Therefore the list will
    // contain pointers to freed memory. In the next loop iteration the memory of the deleted object will be re-used
    // for the buffer and overwritten with the data of the next message.
    for (auto p_msg : messages) {
        try {
            auto p_decoded_msg = new uint8_t[p_msg->get_size()];
            std::fprintf(stderr, "Buffer for decoded message at %p\n", p_decoded_msg);
            p_msg->decode(p_decoded_msg);
        }
        catch (std::exception& e) {
            std::fprintf(stderr, "Exception '%s' occurred while decoding message, deleting object\n", e.what());
            delete p_msg;
        }
    }

    // Trigger UAF condition
    for (auto p_msg : messages) {
        fprintf(stderr, "Type of message %p is %d\n", p_msg, p_msg->get_type());
    }
    return 0;
}