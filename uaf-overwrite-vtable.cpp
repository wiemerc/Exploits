#include <arpa/inet.h>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>


static const int BUFFER_SIZE = 1024;
static const int MSG_DATA = 1;
static const int MSG_END = 2;


// Message format: | type | size | base64-encoded message |
class Message
{
    uint8_t m_buffer[BUFFER_SIZE];
    uint16_t m_type;
    uint16_t m_size;
    uint8_t *mp_decoded_msg;

    public:
        Message(const char *p_buffer, size_t size)
        {
            std::memcpy(m_buffer, p_buffer, size <= BUFFER_SIZE ? size : BUFFER_SIZE);
            m_type = ntohs(*((uint16_t *) m_buffer));
            m_size = ntohs(*((uint16_t *) (m_buffer + 2)));
        }

        virtual ~Message()
        {
        }

        virtual void decode(uint8_t *p_buffer)
        {
            // TODO: Use base64 and actually decode message, see https://stackoverflow.com/questions/180947/base64-decode-snippet-in-c
            std::memcpy(p_buffer, m_buffer + 4, BUFFER_SIZE - 4);
            throw std::runtime_error("Decoding message failed");
        }

        virtual uint16_t get_type() const 
        {
            return m_type;
        }

        uint16_t get_size() const
        {
            return m_size;
        }
};


void pwned_get_type()
{
    std::cerr << "\x1b[31mYou've been pwned!!!\x1b[30m" << std::endl;
}


int main()
{
    std::fprintf(stderr, "Address of pwned_get_type() = %p\n", pwned_get_type);
    std::fprintf(stderr, "Size of Message objects = %ld\n", sizeof(Message));

    char read_buffer[BUFFER_SIZE];
    std::vector<Message *> messages;
    while (true) {
        std::cin.read(read_buffer, BUFFER_SIZE);
        std::fprintf(stderr, "Read %ld bytes from standard input\n", std::cin.gcount());

        // Allocate Message object and store it in list
        auto p_msg = new Message(read_buffer, std::cin.gcount());
        messages.push_back(p_msg);
        std::fprintf(stderr, "Message object at %p, size = %d, type = %d\n", p_msg, p_msg->get_size(), p_msg->get_type());

        // We need to terminate the loop with special message instead of EOF because EOF can only be caused by
        // closing the TCP connection and this causes socat to terminate the program.
        if (p_msg->get_type() == MSG_END)
            break;
    }

    // We try to decode message and, if an exception occurs, delete object but keep it in list.
    // Therefore the list will contain pointers to freed memory. In the next loop iteration the memory of the deleted
    // object will be re-used for the buffer and overwritten with the data of the next message.
    for (auto p_msg: messages) {
        try {
            auto p_decoded_msg = new uint8_t[p_msg->get_size()];
            std::fprintf(stderr, "Buffer for decoded message at %p\n", p_decoded_msg);
            p_msg->decode(p_decoded_msg);
        }
        catch (std::exception &e) {
            std::fprintf(stderr, "Exception '%s' occurred while decoding message, deleting object\n", e.what());
            delete p_msg;
        }
    }

    // Trigger UAF condition
    for (auto p_msg: messages) {
        fprintf(stderr, "Type of message %p is %d\n", p_msg, p_msg->get_type());
    }
    return 0;
}