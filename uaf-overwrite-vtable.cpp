#include <arpa/inet.h>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>


static const size_t MAX_CHUNK_SIZE = 0x40000000;  // 1GB

static const unsigned char b64_index[256] = {
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  62, 63, 62, 62, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0,  0,  0,  0,  0,
    0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 18,
    19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,  63, 0,  26, 27, 28, 29, 30, 31, 32, 33,
    34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
};


class HTTPChunk
{
    unsigned char* mp_buffer;
    size_t m_buffer_size;

    public:
        HTTPChunk(std::istream& input_stream, size_t chunk_size)
        {
            std::fprintf(stderr, "HTTPChunk::HTTPChunk() called\n");
            m_buffer_size = chunk_size <= MAX_CHUNK_SIZE ? chunk_size : MAX_CHUNK_SIZE;
            mp_buffer = new unsigned char[m_buffer_size];
            input_stream.read(reinterpret_cast<char*>(mp_buffer), m_buffer_size);

            // skip over the terminating \r\n sequence
            char dummy;
            input_stream.get(dummy);
            input_stream.get(dummy);
        }

        // The destructor is virtual because in a derived class (which overrides get_decoded_content()), it might have to do more.
        // But the destructor might be called through a pointer to this base class. See http://www.gotw.ca/publications/mill18.htm
        // for a more detailed discussion.
        virtual ~HTTPChunk()
        {
            std::fprintf(stderr, "HTTPChunk::~HTTPChunk() called\n");
            delete[] mp_buffer;
        }

        size_t get_decoded_size() const
        {
            return m_buffer_size * 3 / 4;
        }

        // This method is virtual because there might be specialized derived classes which handle certain types of
        // content like JSON.
        virtual void get_decoded_content(unsigned char* p_buffer, size_t buffer_size)
        {
            if ((m_buffer_size % 4) != 0)
                throw std::runtime_error("Size of base64-encoded data is not a multiple of 4");

            // Code below copied and slightly adapted from https://stackoverflow.com/a/41094722. See also
            // https://matgomes.com/base64-encode-decode-cpp/ for details about implementing base64 encoding / decoding
            // in modern C++.
            int is_padded = m_buffer_size > 0 && (m_buffer_size % 4 || mp_buffer[m_buffer_size - 1] == '=');
            size_t content_size = ((m_buffer_size + 3) / 4 - is_padded) * 4;
            size_t i, j;

            for (i = 0, j = 0; i < content_size && j < buffer_size - 2; i += 4) {
                int n = b64_index[mp_buffer[i]] << 18 |
                    b64_index[mp_buffer[i + 1]] << 12 |
                    b64_index[mp_buffer[i + 2]] << 6 |
                    b64_index[mp_buffer[i + 3]];
                p_buffer[j++] = n >> 16;
                p_buffer[j++] = n >> 8 & 0xff;
                p_buffer[j++] = n & 0xff;
            }
            if (i < content_size)
                throw std::runtime_error("Output buffer is not large enough");

            if (is_padded) {
                int n = b64_index[mp_buffer[content_size]] << 18 | b64_index[mp_buffer[content_size + 1]] << 12;
                if (j < buffer_size)
                    p_buffer[j++] = n >> 16;
                else
                    throw std::runtime_error("Output buffer is not large enough");

                if (m_buffer_size > content_size + 2 && mp_buffer[content_size + 2] != '=') {
                    n |= b64_index[mp_buffer[content_size + 2]] << 6;
                    if (j < buffer_size)
                        p_buffer[j] = n >> 8 & 0xff;
                    else
                        throw std::runtime_error("Output buffer is not large enough");
                }
            }
        }
};


void pwned_destructor()
{
    std::fprintf(stderr, "\x1b[31mYou've been pwned!!!\x1b[0m\n");
}


int main()
{
    std::fprintf(stderr, "Address of pwned destructor = %p\n", pwned_destructor);
    std::fprintf(stderr, "Size of HTTPChunk objects = %d\n", sizeof(HTTPChunk));

    // read request with headers
    std::fprintf(stderr, "Waiting for requests...\n");
    std::fprintf(stderr, "Headers of incoming request:\n");
    std::string line;
    while (std::getline(std::cin, line)) {
        // remove trailing \r
        line.erase(line.find("\r"));
        if (line == "")
            break;
        std::fprintf(stderr, "> %s\n", line.c_str());
    }

    // read data in chunks
    std::fprintf(stderr, "Reading chunks...\n");
    std::vector<HTTPChunk*> chunks;
    unsigned long chunk_num = 0, chunk_size;
    while (true) {
        std::getline(std::cin, line);
        line.erase(line.find("\r"));
        chunk_num++;
        chunk_size = std::stoul(line, nullptr, 16);
        std::fprintf(stderr, "Chunk #%ld has %ld bytes\n", chunk_num, chunk_size);

        if (chunk_size == 0) {
            std::fprintf(stderr, "Final chunk received, terminating\n");
            std::cout << "HTTP/1.1 200 OK\r\n";
            break;
        }
        else if (chunk_size <= MAX_CHUNK_SIZE) {
            // allocate HTTPChunk object and store it in list
            auto p_chunk = new HTTPChunk(std::cin, chunk_size);
            chunks.push_back(p_chunk);
            std::fprintf(stderr, "Chunk object at %p, decoded size = %d\n", p_chunk, p_chunk->get_decoded_size());
        }
        else {
            std::fprintf(stderr, "Chunk size %ld exceeds maximum size, aborting\n", chunk_size);
            std::cout << "HTTP/1.1 400 Bad Request\r\n";
            break;
        }
    }
    std::cout.flush();

    // We try to decode the chunks and, if an exception occurs, delete the object but keep it in the list. Therefore
    // the list will contain pointers to freed memory. In the next loop iteration the memory of the deleted object will
    // be re-used for the buffer and overwritten with the data of the next chunk.
    // The decoded chunks are stored in another vector for later processing.
    std::fprintf(stderr, "Processing chunks...\n");
    std::vector<unsigned char*> decoded_chunks;
    chunk_num = 0;
    for (auto p_chunk : chunks) {
        chunk_num++;
        try {
            auto p_decoded_chunk = new unsigned char[p_chunk->get_decoded_size()];
            decoded_chunks.push_back(p_decoded_chunk);
            std::fprintf(stderr, "Buffer for decoded chunk #%ld at %p\n", chunk_num, p_decoded_chunk);
            p_chunk->get_decoded_content(p_decoded_chunk, p_chunk->get_decoded_size());
        }
        catch (std::exception& e) {
            std::fprintf(stderr, "Exception '%s' occurred while decoding chunk, deleting object\n", e.what());
            delete p_chunk;
        }
    }

    // Later in the code, we do something with decoded chunks...

    // Finally we delete all chunks and thereby trigger the UAF condition. Note that the exploit wouldn't be possible if
    // we deleted the buffers for the decoded chunks first because the `delete` operator garbles the memory blocks.
    for (auto p_chunk : chunks) {
        delete p_chunk;
    }
    for (auto p_decoded_chunk : decoded_chunks) {
        delete p_decoded_chunk;
    }

    return 0;
}