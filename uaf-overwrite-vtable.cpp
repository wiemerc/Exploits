#include <cstdio>
#include <cstring>
#include <iostream>
#include <stdexcept>
#include <string>
#include <vector>


static const int BUFFER_SIZE = 1024;


class Message
{
    char m_buffer[1024];
    int m_type;

    public:
        Message(const char *buffer, size_t size)
        {
            std::memcpy(m_buffer, buffer, size <= BUFFER_SIZE ? size : BUFFER_SIZE);
        }
        virtual ~Message()
        {
            std::cerr << "Message::~Message() called" << std::endl;
        }

        virtual void decode()
        {
            std::cerr << "Message::decode() called" << std::endl;
            throw std::runtime_error("Decoding message failed");
        }

        virtual int get_type() const
        {
            return m_type;
        }
};


void pwned_get_type()
{
    std::cerr << "\x1b[31mYou've been pwned!!!\x1b[30m" << std::endl;
}


int main()
{
    std::vector<Message *> messages;

    while (true) {
        // Allocate memory block of the same size as a Message object =>
        // memory of the previous Message object will be re-used
        char *p_read_buffer = new char[sizeof(Message)];
        std::fprintf(stderr, "Read buffer at %p\n", p_read_buffer);
        std::cin.read(p_read_buffer, sizeof(Message));
        std::fprintf(stderr, "Read %ld bytes from standard input\n", std::cin.gcount());

        // We need to terminate the loop with special message instead of EOF because EOF can only be caused by
        // closing the TCP connection and this causes socat to terminate the program.
        if (std::memcmp(p_read_buffer, "\xef\xbe\xad\xde", 4) == 0) {
            std::fprintf(stderr, "Received terminate message\n");
            break;
        }

        // Allocate Message object and store it in list
        Message *p_real_message = new Message(p_read_buffer, std::cin.gcount());
        std::fprintf(stderr, "Real Message object at %p, size = %ld\n", p_real_message, sizeof(Message));
        messages.push_back(p_real_message);

        // Try to decode message and, if an exception occurs, delete object but keep it in list.
        // Therefore the list will contain pointers to freed memory.
        try {
            p_real_message->decode();
        }
        catch (std::exception &e) {
            std::fprintf(stderr, "Exception '%s' occurred while decoding message, deleting object\n", e.what());
            delete p_real_message;
        }
    }

    // construct virtual table with pwned_decode() as a replacement for Message::decode() and replace original table
    // see https://shaharmike.com/cpp/vtable-part1/ and https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-3-virtual-tables/ for details
//    void *fake_vtable[3];
//    fake_vtable[2] = (void *) pwned_decode;
//    *((void **) p_read_buffer) = fake_vtable;
    std::fprintf(stderr, "Address of pwned_get_type() = %p\n", pwned_get_type);

    // trigger UAF condition
    for (auto p_msg: messages) {
        fprintf(stderr, "Type of message %p is %d\n", p_msg, p_msg->get_type());
    }
    return 0;
}